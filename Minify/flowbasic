#!/usr/bin/env python
"""
    This example shows how to build a proxy based on mitmproxy's Flow
    primitives.

    Heads Up: In the majority of cases, you want to use inline scripts.

    Note that request and response messages are not automatically replied to,
    so we need to implement handlers to do this.
"""
from libmproxy import flow
from libmproxy.proxy import ProxyServer, ProxyConfig
from Minify import BaseMinifyHandeler
import sys
import logging
from urlparse import urlparse
from Minify import dbAccess
import datetime
from pymongo import MongoClient
import uuid
from tools import identifyUser

class Intercept(flow.FlowMaster, BaseMinifyHandeler.Minifyflow, dbAccess.DatabaseObject):
    def __init__(self, server, state, level, log_file, dbClient, dbName, dbCollection):
        flow.FlowMaster.__init__(self, server=server, state=state)
        BaseMinifyHandeler.Minifyflow.__init__(self, functionname=sys.argv[0], level=level, log_file=log_file)
        dbAccess.DatabaseObject.__init__(self,dbClient, dbName, dbCollection)
        self.previous_request_url = ''
        self.url_of_cycle_last_recorded = ''

    def run(self):
        try:
            flow.FlowMaster.run(self)
        except KeyboardInterrupt:
            self.shutdown()

    def handle_request(self, f):
        f = flow.FlowMaster.handle_request(self, f)
        if f:
            f.reply()
        # print((BaseMinifyHandeler.Minifyflow.get_userID(self,f)))
        # print (f.client_conn)
        return f
    def conn_parse(self, server_conn):
        """

        :param server_conn: str
        :return: parsed url
        """
        """
        SSL scheme and non-SSL scheme should be distinguished
        """
        unparsed_url = server_conn[server_conn.find('[') + 1:server_conn.find(']')]
        if unparsed_url + '>' == server_conn:
            # A non-SSL scheme
            unparsed_url = server_conn[server_conn.find(' ') + 1: len(str(server_conn)) - 1]
            parsed_url = urlparse(unparsed_url).path
            return parsed_url[parsed_url.find('.') + 1 : len(parsed_url)] if parsed_url.find(":") < 0 else \
                parsed_url[parsed_url.find('.') + 1:parsed_url.find(':')] # no port number needed
        else:
            # An SSL scheme
            parsed_url = urlparse(unparsed_url).path
            return parsed_url[parsed_url.find('.') + 1: len(parsed_url)] if parsed_url.find(":") < 0 else \
                parsed_url[parsed_url.find('.') + 1:parsed_url.find(':')] # no port number needed
    def record_user(self, user_agent):
        print ("WORKING AS EXPECTED")
        self.insert_user(self.get_user_post(user_agent),)

    @staticmethod

    def get_url_post(url, user_agent):
        return {
            "time" : datetime.datetime.utcnow(),
            "url" : url,
            "user_agent" : user_agent
        }
    @staticmethod
    def get_user_post(user_agent):
        return {
            "uuid":uuid.uuid3(namespace=uuid.NAMESPACE_OID, name = user_agent),
            "user-agent" : user_agent
        }
    def handle_response(self, f):
        # current_accessing_url: the exact file the client want to access
        # url_of_cycle: the url the user accesses in this access cycle
        f = flow.FlowMaster.handle_responseheaders(self, f)
        BaseMinifyHandeler.Minifyflow.process_html(self, f)
        BaseMinifyHandeler.Minifyflow.process_js(self, f)
        BaseMinifyHandeler.Minifyflow.process_all_img(self, f)
        print("Currently Accessing: " + BaseMinifyHandeler.Minifyflow.get_referer(f.request.headers))
        # Use referer to determine a complete access cycle
        if f:
            f.reply()
        url_of_cycle = self.get_referer(f.request.headers)
        self.record_user(user_agent=self.get_user_agent(f.request.headers))

        if(self.url_of_cycle_last_recorded == '' or self.url_of_cycle_last_recorded != url_of_cycle):
            print("User Requested Another Site: " + url_of_cycle)
            self.record_user(user_agent=self.get_user_agent(f.request.headers))
            self.go_to_user_collection(self.get_user_post(self.get_user_agent(f.request.headers)))
            self.insert_url(self.get_url_post(url = url_of_cycle, user_agent=self.get_user_agent(f.request.headers)))
            # TODO optimizing code should be written in here!
            self.url_of_cycle_last_recorded = url_of_cycle
        # code above is used to determine a access cycle
        current_accessing_url = self.conn_parse(str(f.server_conn))
        if(self.previous_request_url == '' or self.previous_request_url != current_accessing_url):
            # print(f.server_conn)
            # print("First Response")
            # print("User Accessing:" + current_accessing_url)
            pass
        self.previous_request_url = current_accessing_url
        # print (self.conn_parse(str(f.server_conn)))
        # print ("User Request: " + str(f.request.headers))
        # print ("User Response: " + str(f.response.headers ))
        return f


config = ProxyConfig(
    port=8080,
    # use ~/.mitmproxy/mitmproxy-ca.pem as default CA file.
    cadir="~/.mitmproxy/"
)



state = flow.State()
server = ProxyServer(config)
m = Intercept(server, state, level=logging.INFO, log_file=BaseMinifyHandeler.Minifyflow.create_log_file(),
              dbClient=MongoClient("localhost", 27017),
              dbName="test",
              dbCollection="access_sites")
m.run()
